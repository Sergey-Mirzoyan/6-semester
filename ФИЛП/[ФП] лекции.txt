11.02.15 -----------------------------------------------------------

Толпинская Наталья Борисовна, 513л
Функциональный язык - ЛИСП, логический - Пролог.
ANSI Common LISP - Пол Грэм
Основы функционального программирования - Л В Городняя
Мир Лиспа, введение в язык и ФП (2 части) - Э Хювёнен, Й Сяпянен

Современные системы программирования включают в себя идеи, появившиеся в лиспе в 58м. Динамическое распределение памяти и тп. При этом лисп не был оценен.

Программа на императивном языке - последовательность команд, каждая приводит к изменению состояния вычислителя. Состояние - состояние памяти. Дискретное изменение состояния вычислителя. Команды группируются в подпрограммы, функции и тд.
В объектном программировании - базовым понятием является объект. Объект обладает свойствами (данными) и методами (подпрограммами). Принципиальное отличие - появление конструкции объекта, обладающее некоторой новизной; в основе лежит использование подпрограмм.
Функциональное (аппликативное) программирование - базовым понятием является функция; за состоянием памяти следить не нужно - важен результат (возврат), а не процесс (состояние памяти). Операторов и команд нет в принципе.
Логическое программирование - поддерживается декларативными языками программирования. Они основаны на системе правил. В отличие от императивного, порядок действий определяется набором правил и не определяется порядком записи в тексте программы.

Ф/ЛП не максимально эффективно, поскольку техника работает по императивным принципам.



LISP - LIST Processing.
Расширяемый язык. Для решения класса задач можно расширить язык в нужном направлении; различные расширения могут серьёзно отличаться друг от друга.
Язык нечисловых вычислений - с его помощью можно считать, можно использовать функции вместо операторов (имена похожи на знаки: sin, + и тп). Язык нацелен на обработку символьных конструкций - нет четкого разделения на данные и программы; программа может строить себя и выполняться.

Базис языка: атом, точечная пара, S-выражение, список.
АТОМЫ - символы (идентификаторы) и константы. Константы - числа (разных типов, но вообще типизация отсутствует) и логические (T,Nil). Всё что не Nil то True.
ТОЧЕЧНАЯ ПАРА - два элемента, синтаксически разделенные точкой и заключенные в скобки. (<атом>.<атом>), (<атом>.<точечнаяпара>), (<точечнаяпара>.<атом>), (<точечнаяпара>.<точечнаяпара>).
S-ВЫРАЖЕНИЕ - либо атом, либо точечная пара.
Список - специальный тип с-выражения. Список::=Nil | (<S-выражение>.<список>). Таким образом, список - рекурсивно определенная структура, которая может быть пустой.
Пример: (A.(B.(C.Nil))) допустима упрощенная запись (A B C). () - признак конструкции, которая в памяти представляется особым образом. (А) - список, А - атом.

В памяти любому списку соответствует конструкция из двух ячеек - списочная ячейка. Списковая ячейка содержит не данные, но два указателя - на голову и хвост. Хвост в свою очередь также список, которому снова соответствует списковая ячейка...
[.][]->[.][]->[.][]->Nil
 V		V	   V
 A		B	   C
При этом точечная пара (A.B):
[.][]->B
 V
 A
Почему базовой структурой выбран список? Это наиболее общая динамическая структура, на основе которой можно организовать стек, очередь и тд. Список позволяет обрабатывать себя как удобно программе.
С точки зрения обработки точечные пары не удобны, потому что их нельзя обрабатывать рекурсивно с условием останова Nil.


Программа.
Программа в лиспе - это список. Элементы списка трактуются так - первый элемент списка - имя функции, остальные элементы - аргументы.
(+ 1 2)
(+ 1 2 3 4)
(+)
Более сложная функция:
(+ 1 (/ 4 2))



18.02.15 -------------------------------------------------------------

Программы в лиспе выглядят как списки. Рассмотрим базовые функции.
Селекторы:
	car , cdr - переход к списковой ячейке
Конструкторы:
	cons - всегда двухаргументная, быстрая. Создает списковую ячейку, расставляя указатели на первый и второй аргумент. Не всегда даёт список, но всегда даёт списковую ячейку.
	list - многоаргументная, всегда создает список (столько СЯ, сколько аргументов).
Предикаты (возвращающие логическое значение):
	atom - одноаргументная, возвращает Т, если аргумент является атомом.
	listp - одноаргументная, является ли списком
	consp - является ли точечной парой.
	null - пуст ли список
	symbolp - является ли символом
	numberp - -''- числом
	zerop - -''- нулём
	oddp , evenp - проверка на четность
	< , >
	eq - сравнивает два символа по указателям, установлены ли указатели на один объект. Позволяет корректно сравнивать логические константы Т и Нил
	eql - используется в стандартных функциях, сранивает числа. Корректно сравниваются только "одного типа" - 3 и 3, но не 3 и 3.0. Не сравнивает списки.
	= - может быть использована в 3 и 3.0.
	equal - сравнивает списки, но не сравнивает разнотипные числа.
	equalp - сравнивает все подряд. ;может не являться "стандартной"
Некоторые функции взаимозаменяемы, но скорость их работы может сильно отличаться. Функция носит частичный характер - на одних аргументах работает корректно, на других нет (например только с числами: < , >)

Первоначально запускается базовая функция eval . Значение символа может быть не только числом, но и другой символом или даже сложная конструкция.
Также есть функция блокирующая вычисления - quote , также ' .
'(A B C) эквивалентно (quote (A B C)).

Цикл работы лисп-машины:
1 read S-выражение
2 eval S-выражение
3 print
4 GOTO 1
В любых императивных системах система печатает только по запросу. Лисп работает по указателям, в процессе работу может преобразовывать значения, и на экран всегда выводится последнее вычисленное значение. Не всегда оно может соответствовать тем преобразованиям, которые прошли в памяти.

Схема работы функции eval.
(eval s-выражение)
1	с-выр атом? -yes->2 -no->7
2	с-выр=t? -yes->3 -no->4
3	печать T *

4	с-выр=nil? ->yes->5 -no->6
5	печать nil *

6	значение s-expr если есть
7	является 1м элементом quote? -yes->8 -no->9
8	s-expr без символа квоты *

9	требует особой обработки? -да->12 -нет->10
10	применить eval ко всем элементам с-выр кроме первого
11	применить первый элемент к остальным *

12	провести обработку в зависимости от функции
13	применить первый элемент к остальным *
В лиспе выделяют особые функции - формы. Можно выделить функционалы, функции более высоких порядков, макросы и тд.


(диаграмма эвалуации функции average, за аналогиями - см. отчет2)

Существуют функции, связывающие атом со значением
set , setf , setq
(setf символ с-выражение) - устанавливает символу значение
(set name value) - вычисляет оба выражения.



Начнем рассматривать стандартные функции лиспа, созданые с использованием базиса.
Специальные формы.
Первая группа - позволяют использовать условные выражения.
(if test T-body F-body) Форма - потому что не вычисляет все аргументы. Всё что не nil то T. Результат теста может быть как атомом (не обязательно нил) так и списком. В зависимости от этого, сработает либо один либо другой аргумент. При этом иф - не базовая функция.
(cond (test1 body1) (test2 body2) ... (testN bodyN) [(T else-body)]) - базовая. Список обратывается от головы, если ни один тест не выполнился, то отрабатывет "елс" с-выражение.

(and arg1 arg2 ... argN) - вычисляет аргументы, пока не станет очевидным результат (появится первый nil). Как только очевиден -  возвращается последнее вычисленное значение.
(or arg1 arg2 ... argN) - аналогично.
(not arg) - работает очевидным образом.

(defun my_compare(x y)
	(cond ((= x y) 'equal)
		  ((< x y) 'first_is_smaller)
		  ((> x y) 'first_is_bigger)
		  (t	   'error))
)
(my_compare 2 4)


(defun how_alike(x y)
	(cond ((or (= x y) (equal x y)) 'the_same)
		  ((and (oddp x) (oddp y)) 'both_odd)
		  ((and (evenp x) (evenp y)) 'both_even)
		  (t 'difference)
	)
)
(how_alike 4 (list 2 7))



21.02.15 -----------------------------------------------------------

Атом представляется в памяти пятью указателями, один из них указывает на значение. Атомы в памяти не дублируются; если где-то возникает значение ссылающееся на этот атом, то просто устанавливается указатель на него.
name	->
value	->

Функция setf работает с указателем value.
Имя - атом может быть связан как значением, так и с функцией; атом может использоваться по-разному.
Существует функция let - позволяет установить значение сразу нескольким атомам. (let ((name1 value1) ... (nameN valueN)) body). Де факто: "пусть Х = 3, У = 4, З = 4, над ХУЗ сделать body".
Простой лет работает так: вычисляются все элементы списков (имя, вал), затем устанавливается связь (перед связыванием J может ещё быть не связано J-1).
Также существует функция let* . Он работает "корректнее", но дольше - вычисляет-связывает, вычисляет-связывает. В этом случаее в J паре можно использовать значение из J-1.

Лексические параметры - формальные параметры, видны только внутри функции.


Способы определения функций
1) Макроопределение defun - не базовое. В начале создания языка была реализована идея, когда пользователь не создавал собственных функций, но строил конструкции из ~десятка базовых. defun - форма, особым образом обрабатывает некоторые из своих аргументов.
(defun имя (список аргументов) (тело)). Тело - вычислимое выражение.

2) Базовый способ определения функции - lambda .
Лисп базируется на математике. Лямбда-выражение - способ записи выражения, когда вначале записывается формула, которую надо вычислить, а затем значения, над которыми её вычислить.
(lambda (аргументы) (тело))
Если определение функции нужно на непродолжительное время - то нет необходимости создавать её на всё время работы.
Первый способ использования лямбд - "тяжеловесный", возник из лямбда-исчисления Чёрча из математики. ((lambda (x,y) (+ x y)) 2 5) - дает 7.
Другой способ - использование apply , особая функция называемая функционалом. Требуется "операция" (слово не очень уместно) #. Если мы используем дефан - то вместо функции нужно указать имя и список фактических параметров. (apply #'name (параметры)). Если используем лямбды - (apply #'(lambda (x y) (+ x y)) (2 5)). Первый вариант поддерживается не всеми диалектами лиспа.
Лямбда-описание часто описается при работе со структурированными списками, обходить которые нужно рекурсивно.


Способы обработки списков
Функции делятся на разрушающие и неразрушающие структуру. Вторые обычно работают дольше - работают с копиями. 
(append lst1 lst2 ) - не разрушает структуру.
	Таким образом (setf lst1 '(a b)), (setf lst2 '(c d)) создадут два списка, на которые будут указывать указатели, и (append)  создает копия первого, и последний указатель устанавливается на второй аргумент. КОПИЯ СОЗДАЕТСЯ ТОЛЬКО ДЛЯ ПЕРВОГО СПИСКА. (setf lst3 (append)) даст доступ к результату работы аппенда, но сохранит доступ к лст1 и лст2.
Дублем аппенда является функция (nconc lst1 lst2); n - символизирует, что не создается копия. Возьмёт последний указатель первого аргумента и установит на второй.

(reverse lst), (nreverse lst) - разворачивают списки задом наперёд.
Все эти функции работают только с верхним уровнем списка - неизвестно, насколько сложно они организованы.

(last lst) - возвращает последнюю по верхнему уровню ячейку списка.
(nth n lst) - возвращает н-ый хвост списка, нумерация от нуля. (nthcdr n lst)
(length lst) - возвращает длину списка.
(remove elem lst) - ищет и удаляет элемент из списка. Например (remove 'a '(a b a c a d)) -> (b c d). ремув отработает некорректно в следующем случае: (remove '(a b) '(a '(a b) c)) -> (a (a b) c); сравнение организовано с помощью eql которая не работает на списках.
Если мы хотим анализировать структурированные части, можно сделать УТОЧНЕНИЕ (remove ... :test #'equal)

Замена старого элемента на новый
(rplaca lst el) - переустановка указателя 1 ячейки
(rplacd lst el) - в  конец
(subst new old lst)
(nsusbst new old lst)
Работа с множествами:
(member el lst) - как обычно, только на верхнем уровне.
(union lst1 lst2) - объединение, получение нового множества (неупорядоченного) без дублей
(intersection lst1 lst2)
(set_difference lst1 lst2) - разность
Возвращают логическое значение:
(subsetp lst1 lst2) - является ли 1 подмножеством 2. Возвращает T если 1 \subseteq 2

Ассоциативные таблицы - метод реализации баз данных. Список не имеет жёсткой структуры - таблицу можно представить в виде списка двухэлементных списков или списка точечных пар. Двухэлементные: ключ+значение, где значение - может быть списком. Но можно использовать несколько ключей; система за этим не следит.
((a 1) (b 2) ... (k 999))
Ради экономии пары можно использовать точечные пары.
(pairlis set_key set_value) - устанавливает связи; мощность множеств должна быть одинаковой.
При этом не проверяется уникальность ключей и значений. Вместо cons можно использовать (assoc key table) - возвращает пару (либо (rassoc value table) для работы со значениями а не ключами). Более того - таблица по сути множество (неупорядочена) и с ней можно работать как с множеством.

Можно модифицировать таблицу, заменить значение по ключу на новое значение.(sublis table lst) - проверяется наличие в лст ключей из таблицы; если ключ обнаружен - происходит замена.


25.02.15 -----------------------------------------------------------

Функционалы
Особые функции, формы, которые в качестве аргумента принимают другие функции. Функционалы часто делят на две группы - применяющие и отображающие.
(apply #'fun argslst ) - применяющий функционал, применяет функцию к списку аргументов. # - функциональная блокировка, ' - блокировка вычислений. Функциональная блокировка ~ function . С её помощью можно зафиксировать контекст определения функции. В случае если функция не имеет свободных переменных, эти два варианта блокирования не отличаются в процессе обработки.
(funcall #'fun arg1 arg2 ...) - fun можно вычислять. Поскольку вычислениям подвергаются символьные выражения, этот функционал позволяет динамично строить выражения функции, применяя её к указанным аргументам. Единственное требование - после вычисления первого аргумента выражение должно представлять собой функции. Результат обработки не может макросом.
funcall является противоположностью function , как eval для quote .

Наиболее используемая - другая группа, отображающие функционалы.
На вход подается функциональный объект и список аргументов. Функциональный объект (функция) применяется многократно к элементам списка; происходит отображение элементов списка в какое-то другое множество.

(mapcar #'fun lst) - fun является одноаргументной функцией. Мапкар поочередно выбирает элементы, на которые указывают кар-указатели списковых ячеек верхнего уровня в списке, и к каждому применяется fun. Результат в список - как для (list (fun a1) (fun a2) (fun a3)).
(mapcar #'(lambda (x) (* x 2)) '(1 2 3 4 5))
(mapcar #'(lambda (x y z) (* x y z)) '(1 2 3 4 5) '(2 4 6) '(10 10))

(maplist #'fun lst) - функция может быть одноаргументная или многоаргументная. Фан применяется ко всему списку, потом к хвосту, потом к хвосту хвоста и так далее.
(maplist #'reverse '(1 2 3 4 5)) ;fun принимает СПИСОК
(maplist #'list '(1 2 3) '(4 5))
(maplist #'append '(1 2 3) '(4 5)) ; не забывать, что аппенд работает с КОПИЯМИ - неэффективный способ!

Мапкар и маплист - основные функционалы, имеющие дубли: mapcar -> mapcan , maplist -> mapcon . Отличие их в том, как собираются результаты. Мапкар и маплист собирают результат list'ом, дубли - с помощью структуро-разрушающих функций nconc .


(find-if #'predicat lst) - применяет предикат к элементам списка; возвращает первый элемент списка, удовлетворяющий предикату.
(remove-if #'predicat lst)
(remove-if-not #'predicat lst)
(remove-if #'odd '(4 2 1 7 6 9))

(reduce #'fun lst) - фун должен быть двухаргументным, применяется каскадным образом. Применяется к первым двум элементам, затем к результату и следующему, новому результату и следующему и так далее пока есть ячейки верхнего уровня.

(every #'predicat lst) - возвращает T, если все элементы удовлетворяют предикату.
(some #'predicat lst) - если хотя бы один.

А теперь пошли примеры

(mapcar #'fun '((a C) (d E) (g H))) - получить C E H отдельным списком - fun == cadr . cAdr - потому что cdr будет возвращать (с) (е) (х) а не с е х.
В то же время - (mapcan #'cdr '((a c) (d e) (g h)))

(mapcar #'cons '(a c) '(d e)) - даст ((A.D) (C.E))
При этом  (maplist #'cons '(a c) '(d e)) - даст (((A C) D E) ((C) E)). Связывается вначале (a c), d, e как один элемент, затем (c) e как другой, то есть ((a c) d e) и ((c) e). собираются листом в один список.

(maplist #'append '(a c) '(d e)) - ((A C D E) (C E). Аппенд связывает a c d e, переходит к хвостам, связывает c e.
(mapcon #'append '(a c) '(d e)) даст (a c d e c e). //ничего подобного, сорвется в бесконечное (a c d e c e c e c e c e ... !

(defun consist_of (lst)
	(if member (car lst) (cdr lst) 1 0)
)
(defun all_last_element (lst)
	(if (eql (consist_of lst) 0)
		(list (car lst))
	)
)
(defun collection_to_set (lst)
	(mapcon #'all_last_element lst)
)
(collection_to_set '(i t i g t k s i f k)) -> (g t s i f k)
Для вводимой коллекции: consist_of даёт (1 1 1 0 0 1 0 0 0 0), далее все 0 добавляются в список.

Функционал, возвращающий декартово произведение списков - (a b) (1 2) - множество всех возможных пар

(defun decart (X Y)
	(mapcan #'
		(lambda (x)
			(mapcar #'
				(lambda (y) (list x y))
				Y
			)
		)
		X
	)
)



04.03.15 -----------------------------------------------------------

Рекурсия (в "философском смысле") - ссылка объекта на самого себя в процессе описания. Рекурсивная функция вызывает саму себя.
В лиспе существует классификация рекурсивных функций:
простая рекурсия - один рекурсивный вызов в теле
рекурсия первого порядка - рекурсивный вызов встречается несколько раз
взаимная рекурсия - используется несколько функций, рекурсивно вызывающих друг друга.

Ряд проблем связан с организацией выхода из рекурсии. Выход может организован не единственным образом. Пример: мы хотим проверить присутствие элемента в списке. Нас интересует только верхний уровень, или все возможные? Два варианта выхода: нашли на первом уровне или нет.
(defun my_member (el lst)
	(cond	( (null lst) nil )
			( (equal el (car lst)) t )
			( t (my_member el (cdr lst)) )
	)
)
(my 'a '(b a c)) -> t
(my nil ()) ->
Некачественный выход из рекурсии может привести к переполнению памяти из-за "лишних" рекурсивных вызовов. Кроме того возможна потеря аргумента - кажется что функция возвращает результат и он используется, но на деле результат теряется и ответ неверен.

Возможны комбинации вариантов - взаимная рекурсия, когда каждая функция рекурсивна первого порядка. Обзор начнем с простой группы функций - хвостовая рекурсия.
В общем виде хвостовая рекурсия описывается так:
(defun fun (x)
	(cond	(end_test1 end_value1)
			(end_testN end_valueN)
			( t (fun reduced_x) )
	)
)
Найти первый нечетный элемент в списке на ВСЕХ его уровнях:
(defun firstodd (lst)
	(cond	( (null lst) nil )
			( (oddp (first lst)) (first lst) )
			( t (first_odd (cdr lst)) )
)) ; Здесь first - выделяет атом из головы списка
(defun first (lst) ; работает НЕ ВСЕГДА, лол
	(cond	( (atom lst) lst )
			( t (first (car lst)) )
))

Дополняемая рекурсия:
(defun fun (x)
	(cond	(test end_value)
			(t (add_fun add_value (fun reduced_x)) )
))
Например:
(defun my_len (lst)
	(cond	( (null lst) 0 )
			( t (+ 1 (my_len (cdr lst))) )
))
; -----------------------------------------------
(defun insert_help (x lst)
	(cond	( (null lst) (list x) )
			( (<= x (car lst)) (cons x lst) ) ; важно - cons может давать точечную пару, а не список
			( t (cons (car lst) (insert_help x (cdr lst))) )
))
(defun sort_help (lst1 lst2) ;lst2 - упорядоченный
	(cond	( (null lst1) lst2 )
			( t (sort_help	(cdr lst1)
							(insert_help (car lst1) lst2)
				) )
))
(defun sort_ins (lst) ; функция-обёртка, предоставляемая пользователю
	( sort_help lst () )
)
; -----------------------------------------------
В качестве дополнительной функции в дополняемой рекурсии очень часто используется cons , которая формирует результат.

Выделяют группу функций множественной рекурсии. На одной ветке происходит сразу несколько рекурсивных вызовов. Количество условий выхода также может зависеть от задачи.
(defun fun (x)
	(cond	(test end_val)
			( t (combine	(fun changed1_x)
							(fun changed2_x)
			) )
))
Часто в вызовах с измененным х используются car И cdr .
Пример: поиск первого числа в смешанном списке.
(defun first_num (lst)
	(cond	( (numberp lst) lst )
			( (atom lst) nil )
			(t (or	(first_num (car lst))
					(first_num (cdr lst))
				)
			)
))
; -----------------------------------------------
(defun cons_cells (lst) ; количество СПИСКОВЫХ ЯЧЕЕК, а не значений как таковых, проверять на списках из ЛР1 з.1
	(if (atom lst) 0
		(+ (length lst)
			(reduce #'+ (mapcar #'cons_cells lst))
		)
	)
)

; -----------------------------------------------
(defun into_one (lst rst)
	(cond	( (null lst) rst )
			( (atom lst) (cons lst rst) )
			( t (into_one	(car lst)
							(into_one (cdr lst) rst)
				)
			)
	)
)
(defun into_one_level (lst)
	( into_one lst () )
)



Способы организации циклов.
(dotimes (var_name end_integer [result_form])
		body
)
(dolist (var_name list_value [result_form])
		body
)
Также существует функция do , работащя с произвольным числом параметров и позволяющая их менять.
(do	( (var1 init1 [update1]) ...
	  (varN initN [updateN]) )
	(test actions1 ... actionsM) ; последняя проверка после всего ^
	body
)
Дубль этой функции: do* с той же конструкцией, но устанавливает связи не в рандомном порядке, а сразу после создания. Качественнее но дольше.

11.03.15 -----------------------------------------------------------

Представления символов (атомов) в памяти.

Символ представляется в памяти структурой из пяти указателей.
name		-> имя в виде строки символов
value		-> как атомарное, так и более сложное; число, другой символ
function	-> указатель на функциональный объект. lambda выступает как опознаватель, что это именно функциональный объект
properties - указатель на список свойств
package - указатель на пакет

Список свойств - список из четного числа элементов. На нечетных позициях - имена, на четных - значения. Ограничен только размером памяти; по символу можно получить доступ к любому свойству

Пакет - способ определения модулей, система имен. Дают возможность отделять имена символьных атомов. Кроме того, позволяют описывать скрытую информацию - определить атомы в одном пакете, чтобы они были недоступны в другом. При этом возможен импорт модулей (на нескольких уровнях доступа).
Испольузется таблица имен, каждый элемент - два указателя. Один указывает на имя (в примере внизу - "total"), другой - на всю область. Одновремнно существует ссылка в структуре атома на эту же таблицу.
При запуске лиспа, по-умолчанию атомы регистрируются в пакете "Common-Lisp-User".

(setf total 'tvl)
(setf tvl 12)
(defun total (x y) (+ x y))

|name		|->"total"
|value		|->	|name	-> "tvl"
|			|	|value -> 12
|			|	+-----
|function	|-> [v|-]>	[v|-]>[v|-]>[v|-]>nil
|			|	lambda	x	   y	|name -> "+"
|			|						|function
|			|						+--------
|properties	|->	[v|-]>	[v|-]>	[v|-]>	[v|-]>nil
|			|	name1	value1	name2	value2
|package	|
+-----------+

(eval total) даст 12
(eval (total 1 2)) даст 3

(boundp 'total)
(fboundp 'total) - T, если существует функциональное определение
(symbol-function 'total) - текст определения функциональной части

Существуют функции, позволяющие создавать наборы свойств, устанавливать свойства и значения.
(putprop symbol_name prop_name prop_val)
(get symbol_name prop_name) -> prop_val
Путпроп работает через гет, поэтому можно:
(setf (get symbol prop_name) prop_value)
Свойство можно удалить по его имени:
(remprop symbol prop_name)
Просмотреть весь набор свойств:
(symbol-plist symbol)

Для создания пакета можно использовать следующую конструкцию:
(setf *package* (make-package 'mine
						:use '(common-lisp)))
В зависимости от версии, система (интерпретатор) может указывать, в каком пакете ведется работа.
(Common-Lisp-User)	> (setf sym 5)
					...
(Common-Lisp-User)	> (in-package mine)
(mine)				> sym
					Ошибка: ...
(mine)				> common-lisp-user ::sym	;возможный, но некорректный способ доступа
					5
Корректный способ доступа атомов в других пакетах: экспорт пакетов
(Common-Lisp-User)	> (setf b 10)
(Common-Lisp-User)	> (export 'b)
					...
(mine)				> common-lisp-user :b
					10
Кроме того, символ можно встроить в пакет с помощью импорта
(mine)				> (import 'common-lisp-user:b) ;одинарное двоеточие: поскольку использовался экспорт
После импорта атома мы получаем доступ ко всему, с чему он был связан - значение, функциональное определение, набор свойств и так далее.



Если в выражении присутствует переменная, не вынесеная в список параметров, то она называется свободной и принимает значение на внешнем уровне непосредственно при вызове функци.

Механизм ключевых слов в макросе defun .
Помимо параметров функции, можно указать необязательные параметры. В списке параметров может быть несолько групп.

1) &optional - необязательные параметры.
(defun tt1 (x &optional y) (list x y))
Если необязательный параметр не указан, то вместо него используется nil.
(tt1 1 2) -> (1 2)
(tt1 3) -> (1 nil)
В момент определения функции можно определить значение необязательного параметра. Можно использовать как константное значение, так и s-выражение, вычисляющее значение аргумента.
(defun tt2 (x &optional (y (+ x z))) (list x y))
(tt2 10 20) -> (10 20)
(setf z 5)
(tt2 10) -> (10 15)

2) &rest - с переменной связывается список.
(defun avg (&rest args)
	(/ (reduce #'+ args) (length args) 1.0)
)
В лиспе переменная может быть связана с атомом, списком, функционалом, числом и так далее. Значением атома может быть объект любого типа. Само понятие типа в лиспе звучит по другому; у переменной есть признак, указывающий, какого она типа в ДАННЫЙ МОМЕНТ.
Если мы заранее не знаем, с каким типом данных связан символьный атом, то мы должны использовать функции, которые корректно будут работать с любым типом данных, или анализировать тип.
(defun square-all (&rest args)
	(if (null args) ()
		(cons (* (car args) (car args))
				(apply #'square-all (cdr args))
		)
	)
)
(defun average-square (&rest args)
	(apply #'average (apply #'square-all args))
)

3) &aux - параметр будет использован в теле функции, но его значение определяется не пользователем, а в заголовке функции
(defun avg (&rest args &aux (len (length args)))
	(/ (reduce #'+ args) len 1.0)
)

4) &key - параметры после него в дальнейшем воспринимаются как ключевые значения ;именованные параметры в других языках, ктрл+ф вверх по :test #'equal
(defun  ff3 (&key x y)
	(list x y))
)
(ff3 :x 1 :y 3) -> (1 3)
(ff3 :y 4) -> (() 4)
(ff3 :y 4 :x 10) -> (10 4)


Абстрактный подход к определению функций.
Функционалы - функции, которые принимают аргументами другие функции. Функции более высокого порядка - результатом их работы является функций, а не значение.
В императивных языках мы пишем подпрограммы и вызываем их многократно с разными значениями аргументов. В лиспе также можно многократно вызывать функцию, но можно написать функцию, которая бы имела обобщенный вид, и с помощью параметризации (использования дополнительного параметра) передавать в неё не данные, а имя используемого функционального объекта.



18.03.15 -----------------------------------------------------------

В лиспе можно целое множество подпрограмм описать как одну. Способы написания функций высших порядков:
Первый способ - функция получает аргументами функциональные объекты. Второй - создать функцию, которая в качестве результата вернет функциональный объект.

1) Копирование списка через все ячейки верхнего уровня.
(defun copy-list1 (x)
	(cond	((null x) nil)
			(t (cons	(car x)
						(copy-list1 (cdr x))
			))
	)
)
2) Объединение двух списков
(defun append1 (x y)
	(cond	((null x) y)
			(t (cons	(car x)
						(append1 (cdr x) y)
			))
	)
)
3) Объединеие двух сортированных списков
(defun sort1 (x y)
	(cond	((null x) y)
			(t (ins	(car x)
					(sort (cdr x) y)
			))
	)
)
(defun ins (a lst)
	(cond	((null lst) (list a))
			((< a (car lst)) (cons a lst))
			(t (cons	(car lst)
						(ins a (cdr lst))
			))
	)
)
Три конструкции используют вначале нулл, затем конс или инс. При этом конс или инс похожи. Попробуем получить одну общую функцию вместо трёх.
Два аргумента - с-выражения, третий - параметр, передавающий функциональный объект
(defun common (x y fn)
	(cond	((null x) y)
			(t (funcall fn	(car x)
							(common (cdr x) y fn)
			))
	)
)
(defun copy-list2 (x)
	(common x nil (function cons)) ; вместо функтион можно использовть #'
)
(defun append2 (x y)
	(common x y #'cons)
)
(defun sort2 (x y)
	(common x y #'ins)
)

Рассмотрим функцию, возвращающую функциональный объект.
(defun compose (f g)
	(function
		(lambda (x) (funcall f (funcall g x)))
	)
)



25.03.15 -----------------------------------------------------------

Крис Окасаки - Чисто функциональные структуры данных

Чистые функции - производят копирование при работе с данными, и в любом случае не портят исходные списки.

Лисп поддерживает метапрограммирование - данные и код рассматриваются одинаково. Текст можно рассматривать как данные. Программа будет видоизменять себя при выполнении.
Проблемно-ориентированный язык.
Ленивые вычисления. При работе с чистыми функциями, например, при удалении вершины из дерева нужно создать новое дерево. Ленивые вычисления - производят операции только в тот момент когда происходит обращение.



01.04.15 -----------------------------------------------------------

	ЛОГИЧЕСКОЕ ПРОГРАММИРОВАНИЕ. PROLOG.

Принцип резолюций - положен в основу языка, работает на предикатах. Существует набор аксиом и выделяют набор теорем, которые доказываются на их основе. Формальная теория проводит доказательства на основе аксиом и доказанных ранее теорем.
Если мы хотим, чтобы система была похожа на интеллект, она должна работать на основе некоторых знаний, которые принимаются за непреложную истину. Математика вывела язык, который позволяет фиксировать формулы. Язык использует алфавит и набор допустимых (разрешенных) выражений.
Искусственный интелект использует "знания", имеющие некоторую особенность относительно "привычных" данных. Предложения языка - факты и правила, на основе которых строятся утверждения и теоремы (факт - частный случай правила).

Способ записи конструкций языка никоим образом не определяет однозначно некоторую предметную область. Таким образом понятие типа отсутствует на корню.
В прологе используется база знаний, и больше ничего фактически.
Основополагающий принцип работы системы - недетерминизм. Получили задание - ищем ответ, при этом не определяется, каким образом оный ответ ищется; метод резолюций встроен в систему и недоступен пользователю.

Знания - более структурированы чем данные, сложные понятия определяются через более простые. Знания обладают внутренней интерпретируемостью - более содержательны чем данные (данные требуют внешней интерпретации), что позволяет делать выводы на их основе. Обладают взаимосвязанностью - позволяют выводить причинно-следственные зависимости. Наконец, обладают активными и пассивными аспектами - могут быть описательными или восприниматься как команды действия.

Синтаксис пролога ограничен; единственная используемая конструкция - терм. Терм - константа, переменная или составной терм.
Константы - символьные (обычно называются атомы), числовые. Атомы начинаются с малой буквы. Существуют специальные атомы :- и ?- . Если 'атом' заключен в кавычки, то можно использовать кириллицу.
Переменные - похожи на символьные атомы; начинаются с заглавных букв или символа подчеркивания. aB - константа, AB - переменная, _ab - переменная. _ - специальный вид, анонимная переменная. Философски, переменная - "способ передачи данных во времени и пространстве"; позволяет хранить данные и передавать их в подпрограммы (например). Анонимная переменная не может быть использована для передачи значения.
Именованные переменные в пределах одного предложения (предложение заканчивается точкой) уникальны: в одном предложении может несколько раз встречаться X и это будет одна и та же переменная; в другом предложении Х - уже другая переменная. Анонимная переменная всегда уникальна - любое её использование это новая переменная, с помощью которой нельзя получить доступ к значению. По сути, анонимные переменные нельзя использовать даже для хранения значений - они используются в алгоритме унификации для "построения шаблона", когда некоторые аргументы при унификации нас не интересуют.

Говорят не о присвоении значения переменной, а о переменной связанной со значением (либо свободной). В прологе испольузется принцип деструктивного связывания - если переменная была связана со значением, то есть возможность разорвать эту связь и сделать её свободной.

Составные термы - f(t1,t2,...,tn), ф - функтор, т - термы. Составной терм может фиксировать знание о том, что между объектами Т существует некоторое отношение (связь), природа которого может быть произвольной.

Структура программы. Программа состоит из базы знаний, описывающих предметную область, и "проблемной ситуации" - вопроса системе, на который та может ответить истина\ложь. База знаний состоит из фактов и правил.
Факт - составной терм.
	student(ivanov, mGTU).
	student(petrov, mGTU).
	student(sidorov, mGU).
Goal
	?- student(ivanov, MGTU).
	?- student(X, mGTU).
Система фактически прикладывает шаблон к каждому утверждению в базе данных. При этом проверяется допустимость - может ли переменная Х принимать значение иванов. Она должна связать переменную с этим значением.

Кроме фактов в базе знаний могут быть и правила (теоремы). Если выполняется ... то справедливо ... . В прологе: ... правда, если выполняется ... . f_p(t1,...,tn) :- A1,A2,...As. А - некоторые термы, зачастую составные. А - тело правила, ф - заголовок правила. Условие - конъюнкция (,) либо дизъюнкция (;). В лабах пользоваться только конъюнкциями.



08.04.15 -------------------------------------------------------------

Программа - факты, правила, вопросы. Факты и правила образуют базу знаний; факт - частный случай правила. Базовая конструкция - терм (константа, переменная или составной терм).
Факты и правила - знания, которыми обладает система. Реализация программы при конкретных исходных данных - частный случай работы программы. Задать исходные данные - задать системе вопрос.
Могут быть ситуации, когда на один и тот же вопрос можно ответить разными способами (вместо да\нет) - "в каких случаях да"; де факто - определить значения переменной.
Факт - безусловная истина; декларация наличия отношения (с придуманным именем) между объектами, в виде составного терма. Если содержит переменную и та принимает значение, то это частный пример факта.

Базовые операции: кванторы существования и всеобщности; конъюнкция дизъюнкция отрицание. Переменные в правиле используются с квантором "для любого", а в вопросе с "существует". В синтаксисе программы кванторы не фигурируют.

Правило. заголовок :- тело. A :- b1, b2, ... ,bn. Правило - "условная истина"; утверждение что между объектами в заголовке существует истиностное отношение при выполнении Bi . При задании вопроса система сравнивает вопрос с заголовками правил и фактов.
'студент'(X), 'студент'(X, MGTU) - разные функторы; при анализе вопроса система сравнивает не только главный функтор но и арность аргументов.

получ_стип(фамилия, успеваемость, условия)
получ_стип(_, отличник, _).
получ_стип(_, успевает, сирота).
Другой вид записи: получ_стип(Х, отличник, У). Если переменная входит в отношение единожды, то её можно заменить анонимной, но ТОЛЬКО в этом случае.
прибавить(Х, 0, Х). - верно; прибавить(_, 0, _) - неверно.

	Логическая программа и правила её обработки.
Иногда описать одно утверждение не получается за одно предложение. Вводится понятие "процедура" - совокупность фактов и правил, имеющих заголовок с одинаковыми главными функторами и одинаковой арностью.
Процедура - описывает одно отношение, которое нельзя сформулировать одним предложением. Такая процедура называется предикатом.

Говорят о чисто-логическом программировании и процедурной реализации программ. Утверждение А истинно тогда и только тогда, когда одновременно выполняются утверждения B1 ... Bn (но не определяется в каком порядке). При этом техника работает пошагово - вначале сравнивается главный функтор, затем список параметров, затем верность В1... Система ищет у термов общий пример.
"Пример" - некоторые переменные имеют одинаковые значения. Система должна найти общий пример, при котором переменным будут приписаны значения.

Подстановка - множество пар вида {xi = ti}, где хи - используемая переменная, ти - терм. Если существует терм A(x1, x2, ... xn) и подстановка \theta={x1=t1, x2=t2, ... xn=tn}, то применение подстановки обозначется A\theta и заключается в замене всех вхождений в терм А переменных хи на значения ти.
Терм В называется примером терма А, если существует такая подстановка \theta, что B=A\theta. C является общим примером термов А,В, если существуют подстановки \theta1, \theta2 такие, что C=A\theta1, C=B\theta2.

вопрос p(x, y, z); в БЗ факт p(1, R, C) - система находит общий пример и только тогда утверждение из БЗ может считаться доказательством истинности.

В структуре программы присутствует описательная часть - необходима больше для программиста, чтобы в процессе компилятор мог "контроллировать" пользователя. Разделы программы (в Visual Prolog):
1. директивы компилятора
2. constants
3. domains. Определяются стандартные домены, которые похожи на типы, с которыми работает компьютер. Можно использовать стандартные домены (symbol, file, integer, ...). Из доменов можно конструировать структуры: имя_структуры = имя_функтора(имя_домена1, ...).
При описании домена элемент может быть вариантным - (например, символом или числом; структурой или "пустотой"), в этом случае используется точка-с-запятой. При этом в прологе отсутствует подобие лиспового nil или NULL, нужно использовать собственный символьный атом.
4. predicates. Похоже на прототипирование функций в си. имяпредиката(имя_домена1, имя_домена2 ...). Можно указывать имена переменных, хотя на программу это влияния не окажет: append(list List1, list List2, list Result).
5. clauses. Факты и правила, предложения программы.
6. goal. цель программы, поставленная как вопрос в виде составного терма. Допускается использовать конъюнкцию и дизъюнкцию: append(A, B, R), is_list(R), Z=X+Y.


	Механизм логического вывода и простейшие правила.
Доказательство основывается на элементарных правилах.
Правило вывода - утверждение о взаимосвязи между допущениями и заключениями, которые справедливы всегда с позиции исчисления предиката.
1. Если факты в программе не содержат переменных и вопрос не содержит переменных, используется правило совпадения. Система считает вопрос истиной если находит пример.
2. Если факты содержат переменные, а вопрос основной, применяется правило обобщения фактов.
3. Факты и вопросы содержат переменные. Для факта выполняется процесс конкретизации, а потом для результата выполняется обобщение.

Унификация термов. Основной процесс доказательства - в процессе работы система выполняет большое число унификаций.
Унификация - попытка "увидеть одинаковость", может завершаться успехом или тупиковой ситуацией (неудачей) - включается механизм отката к предыдущему шагу.



15.04.15 -------------------------------------------------------------

Процесс унификации запускается автоматически, но пользователь имеет право запустить его вручную с помощью утверждения (немного нарушает форму записей) T1 = T2 . Два терма унифицируемы, если:
1) являются одинаковыми константами.
2) Т1 неконкретизированная переменная, а Т2 - константа или составной терм, не содержащий внутри себя Т1. Тогда унификация успешна, причем Т1 конкретизируется значением Т2.
3) Т1 и Т2 неконкретизированные переменные. Унификация успешна всегда, причем Т1 и Т2 становятся сцепленными переменными - двумя именами одного "значения". В этом случае при конкретизации одной вторая получает такое же значение.
//важное замечание: нихрена подобного, "успешна всегда" только во время работы непосредственно алгоритма унификации; если в визуалпрологе написать X = Y, Y = 3 то визуалпролог громко выругается на сорока семи свининых языках и скажет 500 type error. "Получается что унификаций у нас две разных, так и живем" ©Строганов
4) Т1 и Т2 составные термы. Унификация успешна при выполнении трех условий:
	а) имеют одинаковые главные функторы
	б) одинаковые арности (количество аргументов)
	в) попарно унифицируются аргументы этих составных термов


	Алгоритм унификации.
Терм S называется более общим чем терм Т, если T является примером S, а S не является примером T. S называется наиболее общим примером T1 и T2, если S такой их общий пример, который является более общим по отношению к любому другому их примеру.
Есть терм T=f(x1 x2 xn). Если одну переменную конкретизировать значением - это будет пример, f(a, x2, xn), более общий чем f(a, b, xn).
Унификатор двух термов - подстановка, которая будучи применена к двум термам даст одинаковый результат.
Наиболее общий унификатор двух термов - унификатор, соответствующий наиболее общему их примеру.
Теорема: если два терма унифицируемы, то существует единственный с точностью до переименования переменных наиболее общий унификатор.

*	*	*	Собственно алгоритм. Используются три области памяти:
	стек: хранит равенства, унификацию которых надо доказать;
	рабочее поле:  равенство вытащенное из стека, которое сейчас доказываем;
	результирующая ячейка памяти: накапливает наиболее общий унификатор.
Флаг неудачи: 1 если возникла тупиковая ситуация

0.начало. Доказываем Т1=Т2
1.	занести в стек Т1=Т2
2.	положить неудача=0
3.	пока стек не пуст
	4.	считать из стека очередное равенство С=Т
	5.	обработать считанное по правилам:
		а)	если С и Т несовпадающие константы,			то неудача=1, выход из цикла
		б)	если одинаковые константы					то следующий шаг цикла
		в)	если С переменная и Т терм содержащий С,	то неудача=0, выход из цикла
		г)	если С переменная и Т терм НЕ содержащий С,	то отыскать в стеке и в результирующей ячейке все вхождения С и заменить на Т. Добавить в результирующую ячейку равенство С=Т. Следующий шаг цикла
		д)	если С и Т составные термы с разными функторами или разными арностями, то неудача=1, выход из цикла
		е)	если С и Т составные термы с одинаковыми функторами и арностью (S=f(s1 s2 .. sm); T=f(t1 t2 ... tm)), то занести в стек равенство S1=T1, S2=T2 ... Sm=Tm.
	6.	очистить рабочее поле
конец цикла
7.	если неудача = 1 то унификация невозможна
8.	если = 0 то унификация успешна, результирующая ячейка содержит наиболее общий унификатор

Пример:
t(X, p(X,Y)) = t(q(W), p(q(a), b))
шаг	|рез.ячейка				|раб.поле							|стек
----+-----------------------+-----------------------------------+----------------------------------
0	|						|									|t(X, p(X,Y)) = t(q(W), p(q(a), b))
1	|						|t(X, p(X,Y)) = t(q(W), p(q(a), b))	|->X=q(W) ; p(X,Y)=p(q(a),b)
2	|X=q(W)				<-г-|X=q(W)								|p(X,Y)=p(q(a),b)
3	|X=q(W)					|p(q(W),Y)=p(q(a),b)				|->q(W)=q(a) ; Y=b
4	|X=q(W)					|q(W)=q(a)							|->W=a ; Y=b
5	|X=q(W),W=a			<-г-|W=a								|Y=b
6	|X=q(a),W=a,Y=b		<-г-|Y=b								|
		 ||
		\||/
		 \/
\theta={X=q(a),W=a,Y=b} . Если эту подстановку применить к исходным термам, то получим наиболее общий пример. Таким образом, нашли наиболее общий унификтатор.

	Общая схема согласования целевых утверждений.
Общая схема доказательства (сложного) вопроса. Рассмотрим формализованную вычислительную модель. Есть некоторая программа P и вопрос G. Решение задачи с помощью логической программы P начинается с задания вопроса G и завершается получением одного из двух результатов:
	* успешного согласования программы (базы знаний) и вопроса; в качестве побочного эффекта формируется подстановка, которая содержит значения переменных, при которых вопрос является примером программы (примеров может быть несколько)
	* неудача (в условиях заданной базы)

Вычисления с помощью конечной логической программы представляет собой пошаговое преобразование исходного вопроса. На каждом шаге имеется некоторая совокупность целей - утверждений, истинность (выводимость) которых надо доказать. Эта совокупность называется резольвентой - её состояние меняется в процессе доказательства. Успех достигается тогда, когда резольвента пуста. Преобразования резольвенты выполняются с помощью редукции.
Редукция цели G с помощью программы P - замена цели G телом того правила из P, заголовок которого унифицируется с целью. Такие правила будем называть сопоставимыми с целью. Правила в P фиксируют в заголовке отношения между объектами; система подбирает нужные знания.
Процесс поиска правила - подбор теоремы, которую можно использовать для доказательства.

При изменениях, новая резольвента образуется в два этапа.
1. в текущей резольвенте выбирается одна из подцелей (по стековому принципу - верхняя) и для неё выполняется редукция - замена подцели на тело найденного (подобранного) правила
2. затем к полученной коньюнкции целей применяется подстановка, полученная как наибольший общий унификатор цели и заголовка сопоставленного с ней правила.

	Механизм отката (backtrack) и дерево поиска решений.
Каждый новый поиск утверждения - с начала базы. На каждом новом этапе может сложиться одна из трех ситуаций:
1. решение найдено и алгоритм завершен
2. имеется некоторое число дальнейших альтернативных возможностей, какая выгоднее неизвестно
3. решение не найдено, из данного состояния невозможен переход в новое. В этом случае автоматически включается бэктрэкниг (обратный ход трассировки). Происходит возврат на предыдущий этап преобразования резольвенты; отменяется последняя выполненная редукция; выполняется реконкретизация переменных, которые были конкретизированы на последнем шаге.

Дерево поиска решения - формализм для исследования всех возможных путей вычисления; схема, которую можно изобразить для представления работы системы. Корень дерева - вопрос G. Вершины дерева образуют резольвенты, которые в общем случае являются коньюктивными. Для каждого утверждения программы (правила или факта), заголовок которого унифицируется с выделенной подцелью, имеется ребро. На ребрах дерева записываются подстановки, которые возникают в результате унификации выделенной подцели и заголовка соответствующего правила. Лист дерева называется успешной вершиной, если резольвента ему соответствующая - пуста; безуспешной, если резольвента непуста и нет утверждений в базе знаний, которые унифицируются с выделенной в этой вершине подцелью.



22.04.15 -------------------------------------------------------------

При обработке резольвенты, стек растёт влево, первым для доказательства выбирается, соответственно, левое. Выбор правила для дополнительного доказательства происходит сверху-вниз. При этом система выбирает для доказательства истинности только те знания (зафиксированные отношения между объектами), которые подходят для данного вопроса. Вначале проверяется главный функтор, затем арность; наконец должны попарно унифицироваться все аргументы в теле терма и в вопросе.

Назначение унификации - подобрать знание (путем последовательного сравнения), которое предположительно можно использовать для доказательства истиности вопроса. Механизм унификации запускается при проверке каждого рассматриваемого знания.
При неудаче, найти другой вариант решения - найти другое подходящее знание. Для доказательства одной и той же подцели на некотором шаге может быть выбрано правило; при нахождении решения или неудаче - происходит возврат. Если в конкретном шаге для конкретного состояния резольвенты (верхушки) есть несколько альтернатив, то система будет испытывать их в порядке записи, и в конечном итоге перейдет в другое состояние.
Существенен порядок поиска, поскльку может происходить большое количество работы. Если поменять в базе два знания местами (описать два условия в теле правила), то может перестроиться всё дерево поиска.

	Системные предикаты
Отсечение - позволяет отсекать бесперспективные ветки дерева решений. Обозначается символом !
p1 :- a, b, !, c, d
Если А истина - система последовательно пытается доказать Б. На каком-то этапе Б может понадобиться пересогласовать. Если мы доказали А и Б, то ! воспринимается как истиный предикат при прямой трассировке, система переходит к доказательству Ц. Если пересогласование потребуется в пределах Ц и Д, то оно произойдёт. Если же произойдёт попытка "пересечь" отсечение на обратном ходе, будет завершено выполнение всей процедуры - ни одна другая возможная ветка не должна быть использована.
//более понятный пример: ниже через две лекции, про максимум из двух элементов, когда система ВНЕЗАПНО выдает два ответа. также неплохое описание на http://www.learnprolognow.org/lpnpage.php?pagetype=html&pageid=lpn-htmlse43
fail - "ложный предикат", если система натыкается на него, то возвращается "нет". Часто используется как "  !, fail."

	Нотация списков в прологе
Пролог допускает использование рекурсивных процедур (совокупностей правил, имеющих идентичные заголовки). Знания могут быть описаны рекурсивно с использованием правил. Если при доказательстве истинности подцели выбрано правило, которое содержит терм, требующий для доказательства истинности использовать это же правило, оно будет рекурсивным. Необходимо утверждение для выхода из рекурсии. Рекурсивная процедура содержит хотя бы одно правило, терм которого сопоставим с заголовками правил из этой процедуры. Для доказательства утверждения будет выбрана та же процедура.
Выход из рекурсии часто организуется с помощью фактов.

Исторически, первый способ оформления списков - в виде составных термов. Как вариант: в виде бинарного дерева, "точечной пары", голова и хвост. Пустой список оформляется в виде пустых квадратных скобок []. Первый способ: .(1,.(2,.(3,[]))), чрезвычайно тяжеловесен.
Последовательность элементов в [] через запятую; терминальный список можно не писать. [a, b, c, []] === [a, b, c]
Если какой-то элемент в свою очередь не атом а список, то он также записывается в квадратных скобках.
Передать список: в вопросе; в правиле - переменная. В прологе список обрабатывается особым образом: список можно разделить на две части. Чтобы дать системе понять что использовать нужно не голову|хвост а другое разделение, используется спецсимвол | . [a, b| c d] - начало и остаток. Системе разрешено перемещать разделитель: === [a| b, c, d].
Пр этом, ^ запись некорректна; корректная форма: [a, b| [c, d]] === [a| [b, c, d]]. Начало должно содержать как минимум один элемент, остаток - всегда список - связан с одной перменной. Попытка сравнения с [X, Y, Z, W] не пройдёт.
Продолжая двигать разделительную черту можно получить [a, b, c|[d]] === [a, b, c, d| []]. Таким образом начало не может быть пустым, а хвост - может. При этом разделительную черту нельзя сместить далее, если остаток - уже пустой список.
Синтаксически, структура [a, b, c| d] не будет являться списком - не эквивалентна | [d]]
Сравнить можно [a, b| [c, d]] и [X, Y| Z] или [_, Y| Z]



29.04.15 -------------------------------------------------------------

Процедура - совокупность правил, которые используются для доказательства подцели. Если для доказательства нужно несколько раз использовать эту процедуру, нужно "передавать" на каждый новый шаг рекурсии другие аргументы исходного списка. Если мы хотим использовать процедуру "повторно", то в её теле должна быть ссылка на саму себя. Таким образом, рекурсивная - процедура, у которой в теле одного из правил есть ссылка на саму эту процедуру. Для доказательства истинности тела будет выбрано одно из правил этой же процедуры.

В списке может быть лишь одна разделительная черта; тем не менее в структурированном списке, в каждом подсписке может быть своя черта. При необходимости, один список может быть несколькими способами разделен на начало и остаток:
[a, b, c, d] === [a | [b, c, d]] === [a, b | [c, d]]
После разделительной черты может стоять только одна перменная; один список.

Рассмотрим несколько примеров.
[L] = [] - унификация невозможна.
[L] = [a|[]] - унификация возможна; система должна в обоих списках так поставить разделительную черту, чтобы количество элементов совпадало.
[L] = [a, b, c] - унификация невозможна. Л - единственная переменная. Система пытается поставить разделительную черту после неё (начало не может быть пустым); во втором списке как бы мы не ставили черту, мы либо будем пытаться конкретизировать переменную несколькими значениями, либо конкретизировать значением пустой список.
[L, b] = [a, b] - унификация возможна.
[[L], b] = [a, b] - невозможна, поскольку в правой части первый элемент - атом, а в левой - список.
[a, L] = [a, b, c] - первая попытка: [a | [L]] = [a | [b, c]]; остаток - один список, которым можно конкретизировать переменную. Унификация возможна, Л конкретизируется не двумя элеметами, а одним списком.
[a, L] = [a, b | [c]] - система попытается перенести разделительную черту влево; унификация снова возможна.

Процедура, определяющая является ли параметр списком.
list(L) :-
	L=[].
list(L) :-
	L=[_|T],
	list(T).
Упрощённая версия:
list([]).
list([_|T]) :- list(T).

Схема описания работы процедуры ^ на list([1, 2, 3])
ТР - текущая резольвента, ТЦ - текущая цель, №№ шаг внутри рекурсии; попытка применения правил ПР1 или ПР2 на очередном шаге рекурсии. На каждом шаге рекурсии создаются дубли переменных - обозначать будем T1 на первом шаге рекурсии, T2, ...
ТР: list([1,2,3])
шаг1:	ТЦ: list([1,2,3])
	ПР1:	[] = [1, 2, 3] унификация невозможна //правило1
	ПР2:	[_|T1] = [1, 2, 3] => T1 = [2, 3]
ТР: list([2,3])
шаг2:	ТЦ: list([2,3])
	ПР1:	[] = [2,3] невозможно
	ПР2:	[_|T2] = [2,3] => T2 = [3]
ТР: list([3])
шаг3:	ТЦ: list([3])
	ПР1:	[] = [3] невозможно
	ПР2:	[_|T3] = [3] => T3 = []
ТР: list([])
шаг4:	ТЦ: list([])
	ПР1:	[] = [] => возможно
ТР: пусто; успех
возврат
ТР: list([])
	ПР2: [_|T] = [] невозможно //успех единственный; в противном случае - необходимо использовать отсечение, чтобы при возврате система не улетела вглыбь.



06.05.15 by vlad------------------------------------------------------

Примеры обработки списков

а) является ли Х элементом L
member(X,L):-
	L=[H|T],
	X=H.
member(X,L):-
	L=[H|T],
	member(X,T).

б) оптимизация
member(X,L):-
	X=H, % по сути даем переменной второе имя
	L=[H,_].
member(X,L):-
	L=[_|T],
	member(X,T).

в) дальнейшая оптимизация, отбрасывание "второго имени"
member(X, [X|_]).
member(X,[_|T]):-
	member(X, T).

г) возможно использование отсечения
member(X, [X|_]):-!. % не даст рекурсии сорваться во второе правило после выполнения первого
%в прошлых вариантах, даже после того как выполнялось первое для 1, [1,2,3], всё равно происходила проверка для 1, [2,3]
member(X,[_|T]):-
	member(X, T).

д) без использования отсечения "оптимального" поведения ^ можно добиться с помощью дополнительной проверки
member(X, [X|_]).
member(X,[H|T]):-
	X<>H, % 'не равно'
	member(X, T).
	

пример для в.
?-member(a, X).

ТР	member(a, X).
Шаг1
	ПР1 a = X1, X = [X1|_]
ТР пусто - да {X=[a|_]}
отказ ТР member(a, X).
Шаг2
	ПР2 a = X2, X=[_,T2]
	ТР member(a, T2)
Шаг3
	ПР1 a =X3, Т2 = [X3|_]
	ТР пусто - да Т2 = [X3|_], X=[_,T2]=X=[_|[a|_]]

...

объединение списков

append([],L2,L2).
append([H|T], L2, [H|T3]):-
	append(T, L2, T3).



13.05.15 -------------------------------------------------------------

Система использует механизм отката; база знаний просматривается сверху-вниз. Одни и теже процедуры могут выбираться многократно при обработке. Если получен успех или возникает тупиковая ситуация, включается механизм отката. Возможно использование отсечения, для того чтобы запретить системе лишний раз использовать какие-то процедуры, и fail для включения принудительного механизма отката.
Рекурсивно одна и та же процедура выбирается несколько раз; чтобы определить, какое следующее правило в базе знаний исследовать, система проставляет метки, помечая использованное в последний раз правило. При откате эта метка спускается "ниже" (по базе знаний). Программа завершит работу, когда метки окажутся "в конце" базы знаний.
В процессе поиска решений резольвента может не уменьшаться, а увеличиваться - как правило в этом случае программа составлена плохо.

Рассмотрим пример из лабораторных.
max(X, Y, X) :- X > Y.
max(X, Y, Y).
Будет работать неправильно! Если второй аргумент будет больше, первое условие не сработает, произойдёт откат, перейдем ко второму правилу, получим правильный ответ. Тем не менее:
ТР: max(5,2,R)
шаг1:	цель:	max(5,2,R)
	ПР1 5=X1, 2=Y1, R=X1
		ТР:	X1>Y1 (на деле: 5>2, подстановка уже выполнена)
шаг2:	цель:	5>2
	выполнение системного предиката
		ТР: пуста; успех => R=5
ответ {R=5}
Включается механизм отката: метка спускается на правило2, восстанавливается резольвента шага 1
		ТР: max(5,2,R)
шаг3:	цель:	max(5,2,4)
	ПР2	5=X3, 2=Y3, R=Y3
		ТР: пуста; успех => R=2
ответ {R=2}
Откат: метке спускаться некуда, завершение работы программы.

Получили два ответа, что естественно неправильно. Необходимо либо поставить проверку во втором правиле (max(X, Y, Y) :- X <= Y.), либо добавить отсечение в первое правило (max(X,Y,X):-X>Y,!.)

max(X,Y,X):-X>Y,!.
max(X,Y,Y).
ТР:	max(5,2,R)
шаг1:	цель:	max(5,2,R)
	ПР1 5=X1, 2=Y1, R=X1
		ТР: 5>2,
			!
шаг2:	цель:	5>2
	выполнение системного предиката, успех
	ТР: !
шаг3:	цель:	!
	ТР: пуста; успех => R=5
{R=5}
Откат: неудача, поскольку при попытке восстановления резольвенты встречается резольвента


Пример неоптимальной работы хвостовой рекурсии. Определение длины списка.
length([],0).
length([_|T],N) :-
	length(T, NN),
	N = NN+1.
ТР: length([a,b,c],N)
шаг1:	цель:	length([a,b,c],N)
	ПР2 [b,c]=T1, N=N1
		ТР: length([b,c],NN1),
			N1=NN1+1
шаг2:	цель:	length([b,c],NN1)
	ПР2 [c]=T2, NN1=N2
		ТР: length([c],NN2),
			N2=NN2+1, //резольвента увеличивается
			N1=NN1+1
шаг3:	цель:	length([c],NN2)
	ПР2 []=T3, NN2=N3
		ТР: length([],NN3),
			N3=NN3+1,
			N2=NN2+1,
			N1=NN1+1
шаг4:	цель:	length([],NN3)
	ПР1 []=[], NN3=0
		ТР: NN2=0+1, //просто восстановили NN2=N3, ...
			NN1=NN2+1
			N=NN1+1
	......
В других случаях в нарастающей резольвеньте могут быть далеко не элементарные термы, что существенно замедлит выполнение программы.


Другой пример: удаление элементов из списка.
1 delete(_, [], []). % что, откуда, результат
2 delete(X, [X|T], Res) :-
	delete(X, T, Res).
3 delete(X, [Y|T], [Y|Res]) :-
	X<>Y, % поскольку просто по именам Х и У мы не можем сказать что это разные элементы
	delete(X, T, Res).
ТР: delete(2, [2,3,2,4], R)
шаг1:	цель:	delete(2, [2,3,2,4], R)
	ПР2 2=X1, [3,2,4]=T1, R=Res1
		ТР: delete(2, [3,2,4], Res1)
шаг2:	цель:	delete(2, [3,2,4], Res1)
	ПР3 2=X2, 3=Y2, [2,4]=T2, Res1=[Y2|Res2]
		ТР: 2<>3,
			delete(2, [2,4], Res2)
шаг3:	цель:	2<>3
	выполнение системного предиката, успех
		ТР:	delete(2, [2,4], Res2)
шаг4:	цель:	delete(2, [2,4], Res2)
	ПР2 2=X4, [4]=T4, Res2=Res4
		ТР: delete(2, [4], Res4)
шаг5:	цель:	delete(2, [4], Res4)
	ПР3 2=X5, 4=Y5, []=T5, Res4=[Y5|Res5]
		ТР: 2<>4,
			delete(2, [], Res5)
шаг6:	цель:	2<>4
	выполнение системного предиката, успех
		ТР: delete(2, [], Res5)
шаг7:	цель:	delete(2, [], Res5])
	ПР1 []=[], []=Res5
		ТР: пуста; успех;
R = Res1 =[Y2|Res2], Res2 = Res4 = [Y5|Res5]; Res5 = [] => R = [3|[4|[]]]

Модификация:
1 delete(_, [], []).
2 delete(X, [X|T], T) :- !.
3 delete(X, [Y|T], [Y|Res] :- delete(X, T, Res)



20.05.15 -------------------------------------------------------------

	Метод резолюций
Является формальным алгоритмом преобразования логических формул, позволяет автоматизировать доказательство. Преобразовывает формулу от общего вида к более простому, который позволит более точно выполнить преобразование автоматически. Доказательство, что из базы знаний (множества утверждений) следует утверждение; теорема.

Преобразование выполняется в несколько шагов.
1. преобразование логической формулы к предваренной (префиксной) нормальной форме. кванторные операции выносятся в начало формулы. Qi - квантор существования \exists или всеобщности \forall; (Q1x1)(Q2x2)...(QnXn)M. Совокупность кванторов - префиксом, оставшаяся часть - матрицей (не содержит кванторных операций).
Преобразование исходной формулы к предваренной форме выполняется в этапов:
	а) удаляются связки <->, ->
	б) отрицание вносится в скобки
	в) переменные связанные кванторами переименовываются если необходимо, чтобы разными кванторами были связаны разные переменные
	г) полученное приводится к предваренному виду
2. сколемизация формулы (по имени норвега Сколем): из формулы в предваренном виде исключаются кванторы существования. Вносятся дополнительные (сколемовские) функции в формулу по определенным правилам:
	а) Если левее первого встречающегося квантора существования нет ни одного квантора всеобщности, то вводится константа C, отличающаяся от других констант в матрице формулы, соответствующая переменная (ранее связанная квантором существования) заменяется на C, а квантор существования вычеркивается.
	б) Если левее квантора, связывающего переменную X префикс содержит m кванторов всеобщности, относящихся к переменным y1...ym, то вводится m-местный функциональный символ F, отличающийся от уже содержащихся в матрице формулы, и все входения переменнной Х в матрице заменяются на f(y1,...,ym), а квантор существования вычеркивается.
(\forall y1)(\forall y2)(\exists x)(\forall z) A(y1, y2, x, z) === (\forall y1)(\forall y2)(\forall z) A(y1, y2, f(y1,y2), z).
После этого кванторов существования в формуле не будут, а оставшиеся переменные будут связаны только кванторами всеобщности.
3. исключение кванторов всеобщности и переход к "клаузальной" (clause) формуле. Поскольку все переменные связаны квантором всеобщности, то можно условиться и оные кванторы отбросить (при этом порядок их следования не важен). Остается матрица M, в которой встречаются операции конъюнкции, дизъюнкции и отрицания. Для использования метода резолюций, полученная формула преобразуется к конъюнктивной нормальной форме, а затем к клаузальной форме.

Клауза (предложение) - отдельная часть КНФ, заключенная в скобки (дизъюнкт). КНФ - множество дизъюнктов (множество клауз, клаузальное множество).

В отдельный дизъюнкт могут входить операции отрицания и дизъюнкции. В общем форме, отдельная клауза представляет собой not(A1) or not(A2) or ... or not(Ak) or not(B1) or ... or not(Bn).
При этом вводят классификацию: (not(A) or B === A->B)
1) k=0,n=1		=> "ничего -> B(t1, ..., ts)". Имеем формулу, соответствующую факту - заключение без предпосылки
2) k>=1,n=0		=>	"A1 and A2 and ... and Ak -> ничего". Формула, соответствующая вопросу - предпосылка без заключения
3) k>=1,n=1		=>	"A1 and A2 and ... and Ak -> B". Соответствует правилу - если выполняются условия, то справедливо утверждение.
^ три формулы соответствуют конструкциям, используемым в прологе. Называются клаузами (дизъюнктами) Хорна; заключение состоит не более чем из одного утверждения.
4) k=0,n>=1		=>	"ничего -> B1 or B2 or ... Bn". Используется при описании нечеткой информации, невозможно сказать, какое именно из выражений является истиной.
5) k>=1,n>=1	=>	"A1 and A2 and ... Ak -> B1 or B2 or ... Bn".

Преобразование исходной формулы требует записать логическое утверждение вначале в произвольной форме, далее эту формулу надо преобразовать и получить множество клауз Хорна. При этом, попытка использовать общую форму клауз при доказательстве приводит к комбинаторному взрыву. Метод резолюций не был эффективен, пока не было предложено ограничиться только первыми тремя формами.

Собственно метод резолюций для логики высказываний.
Был доказан в 1965 году. Основывается на следующем утверждении: Если есть утверждения, и в одну из формул входит not(X), а в другую Х, и обе они истинны( A||!X, B&&X), то две формулы можно преобразовать к одной A || B (правило резолюции). Формул А и Б называются контраными, а множество {Х, !Х} называется контрарной парой.
Правило построения резольвенты двух дизъюнктов. Если в дизъюнкте C1 существует литера L1, контрарная литере L2 в дизъюнкте C2, то вычеркнем из обоих дизъюнктов Л1 и Л2, и объединим операцией дизъюнкцией оставшиеся литеры С1 и С2. Полученный дизъюнкт называется резольвентой исходных С1 и С2. Далее возможны два варианта:
а) если дизъюнкты С1 и С2 содержали по одной литере Л1 и Л2 соответственно, то резольвента является пустой, т.е. ложь.
б) если дизъюнкты С1 и С2 входят в некоторое клаузальное множество и содержат контрарную пару, то их резольвента является их логическим следствием, и её добавление к клаузальному множеству не влияет на заключение о его совместимости.
Резолюцией называется правило,  генерирующее резольвенты из некоторого множества дизъюнкций.
Существует теорема: противоречивость некоторого конечного множества дизъюнктов вытекает из наличия среди его резольвент пустого дизъюнкта.

Переходя к работе системы.
Предположим, что задано некоторое множество правильно построенных формул A1...Ak и формула B. Требуется доказать, что В следует из множества формул А. Используется принцип опровержения - вместо того чтобы доказывать истинность того, что из конъюнкции А следует Б, доказывается что отрицание конъюнкции А ложно при любой интерпретации. A1 && A2 && ... Ak -> B преобразуется к виду !(!(A1&&...Ak) ||B) === A1 && A2 &&... Ak && !B и доказывается его ложность.
A1 && A2 &&... Ak && !B можно свести к клаузальному множеству, выполнив перечисленные преобразования, и при наличии в нем пустого дизъюнкта можно сделать вывод, что формула ложна, а значит исходная - истинна.

При построении резольвент, каждая новая добавляется к клаузальному множеству, не нарушая "значений формулы".

Таким образом, основная идея метода резолюций (его формализация) - в проверке по порядку двух случаев:
1) содержит ли клаузальное множество пустой дизъюнкт
2) если не содержит, выводится ли из него пустой дизъюнкт.
База знаний - множество истинностных утверждений, фактов и правил (клауз Хорна). База знаний: A1 && ... Al, B - вопрос который мы хотим доказать. Записывается отрицание формулы, которую мы хотим вывести, добавляется некоторая часть базы знаний (содержащая контрарный символ), и наконец происходит попытка построения резольвенты.

Общая схема доказательства методом резолюций логического следования формулы (В) из клаузального множества.
1. отрицание формулы В преобразуется к клаузальной форме (по шагам) и добавляется к заданному множеству дизъюнктов (клаузальному).
2. добавленная формула (отрицание) используется для построения первой резольвенты
3. в каждой следующей резолюции (шаге преобразования) должна участвовать резольвента предыдущего шага. Если на некотором шаге нельзя построить новую резольвенту, значит исходная формула В невыводима из заданного клаузального множества.
4. если в качестве резольвенты на одном из шагов будет получен пустой дизъюнкт, то исходная формула В является следствием заданного множества дизъюнктов

Для логики предикатов первого порядка (при наличии переменных, ^ относилось к фактам), метод резолюций требует при построении резольвенты провести унификацию для контрарной пары, а сама резольвента должна быть построена с учетом подстановки, полученной при унификации контрарной пары. 